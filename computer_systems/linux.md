# Linux

## Kernel tasks:

- System initialization: detects hardware resources and boots up the system
- Process scheduling: determines when processes should run and for how long
- Memory management: allocates memory on behalf of running processes
- Security: Constantly verifies filesystem permissions, firewall rules
- Provides buffers and caches to speed up hardware access
- Implements standard network protocols and filesystem formats

## Kernel Initialization

When the power is applied to an embedded Linux system, a complex
sequence of events is started. After a few tens of seconds, the
Linux kernel is operational and has spawned a series of application
Programs as specified by the system init scripts.

Upon power-on, the bootloader in an embedded system is the first
software to get processor control. After the bootloader has performed
some low-level hardware initialization, control is passed to the Linux
kernel. This can be done in two ways:

1) A manual sequence of events to facilitate development process
2) Automated startup sequence typical of a production environment

## Embedded Linux

Linux kernel is only a small component of an embedded system
based on Linux. In addition to the Linux kernel, you need the
following components to develop, test, and launch your embedded
Linux project:

- A **cross-compiler** and associated **toolchain** for your chosen architecture.
It's a set of tools that compiles source code into executables that can run on
your target device and includes a compiler, a linker, and runtime libraries.


- A **bootloader** ported and configured for your specific hardware platform. 
It's the program that initializes the board and loads the Linux kernel.

- **Linux kernel** which is the heart of the system, managing system resources and
interfacing with hardware.

- A **root filesystem** containing many packages - binary executables and libraries
compiled for your native hardware architecture/processor. Contains libraries and
programs that are run once the kernel has completed its initialization.

Optionally there are other elements, such as:

- **Device drivers** for any custom devices on your board.

- A **device tree** enabled for your particular processor and board. It's a data
structures that describe the device hardware.

- The collection of **programs** specific to your embedded application that makes
the device do whatever it is supposed to do, e.g. display movies, control a robot,
fly a drone, etc.

These are the components of an embedded Linux distribution.

## Selection hardware for embedded Linux

1. A CPU architecture that is supported by the kernel - find them at linux repo at
arch/ directoy, all of them are 32 or 64 bits, and most of them have MMU.

2. A reasonable amount of RAM - 16 MiB is a good minimum.

3. Non-volatile storage - usually flash memory. 8 MiB is enough for a simple device
such as a webcam or a simple router.

4. A serial port is very useful, preferably a UART-based serial port. It doesn't
have to be fitted in production boards, but makes board bring-up, debugging, and
development much easier.

5. You need some means to load software when starting from scratch. JTAG is very
common, but modern SoCs support SD and micro SD cards, or serial interfaces such
as UART or USB.

## Toolchains

It's a set of tools that compiles source code into executables that can run on
your target device and includes a compiler, a linker, and runtime libraries.

Tolchains examples:

  - Based on components from *GNU* project (the majority of Linux systems use this)
  - *Clang* compiler and the associated *Low Level Virtual Machine (LLVM)* project.

As of 2021, GNU toolchain is the most popular and mature toolchain for Linux.

A standard GNU toolchain consists of three main components:

  - Binutils: A set of binary utilities including the assembler and the linker.
  - GNU Compiler Collection (GCC): These are the compilers for C and other
  languages.
  - C library: A standardized application program interface (API) based on POSIX
  specification, which is the main interface to the operating system kernel for
  applications.

Toolchains can be native and cross-toolchains.

Three ways to find a toolchain: 1) ready-built toolchain that matches your needs 2) use a
generated by an embedded build tool (e.g. Yocto or Buildroot) 3) create one yourself

## Drivers

A driver is a bit of code that runs in the kernel to talk to some hardware device. It "drives"
the hardware. Most every bit of hardware in your computer has an associated driver.¹ A large
part of a running kernel is driver code.

A driver may be built statically into the kernel file on disk.³ A driver may also be built
as a kernel module so that it can be dynamically loaded later. (And then maybe unloaded.)

### Char vs Block Drivers

- Char drivers: Character device drivers normally perform I/O in a byte stream.
- Block drivers: Devices that support a file system are known as block devices. Drivers written for these devices are known as block device drivers. 

### Kernel Drivers vs User Space Drivers 

User space driver vs Kernel space driver - checar el pdf de linux-kernel-slides.pdf p.46

Difference between drivers and modules: https://unix.stackexchange.com/questions/47208/what-is-the-difference-between-kernel-drivers-and-kernel-modules

## Kernel or Module?

The **kernel image** is a **single file**, resulting from the linking of all
object files that correspond to features enabled in the configuration.

- This is the file that gets loaded in memory by the bootloader
- All included features are therefore available as soon as the kernel starts,
at a time where no filesystem exists

Some features (device drivers, filesystems, etc.) can however be compiled as
**modules**. A module is a compiled code that can be inserted into the kernel at run-time.
You can insert the modules using insmod or remove it using rmmod, or use modprobe to
do both tasks.

- These are plugings that can be laoded/unloaded dynamically to add/remove
features to the kernel
- Each **module is stored as a separate file in the filesystem** (.ko file),
and therefore access to a filesystem is mandatory to use modules.
- This is not posible in the early boot procedure of the kernel, because no
filesystem is available.

## Kernel Compilation Results

- **vmlinux**, the raw uncompressed kernel image, in the ELF format, useful
for debugging purposes, but cannot be booted
- arch/< arch >/boot/*Image, the final, usually compressed, kernel image that
can be booted
  - bzImage for x86, zImage for ARM, Image.gz for RISC-V, vmlinux.bing.gz for
    ARC, etc.
- arch/< arch >/boot/dts/*.dtb, compiled Device Tree files (on some
architectures)
- All kernel modules, spread over the kernel source tree, as .ko (kernel
object) files.
 
## Process Management

Understand the concept (definition) of the process and related concepts as threads. Then discuss how the 
Linux kernel manage each process (how they are enumerated within the kernel, how are they created, and
how they die). 

Because running user applications is the reason we have operating systems, the process management is a crucial
part of any OS kernel, including Linux.

### Process

"Everything in Unix that is not a file is a process"

A process is one of the fundamental abstractions in Unix operating systems. A process is a program (a set of instructions
loaded into memory) in the midst (middle) of execution. 

Process are, however, more than just the executing program code (often called the text section in Unix). They also include
a set of resources such as:

- Open files and pending signals
- Internal kernel data
- Processor state
- A memory address space with one or more memory mappings
- One or more threads of execution, and
- A data section containing global variables

Processes, in effect, are the living result of running program code.

Each running program, called a process, has a number of file descriptors associated with it. PID = Numeric Process
ID used for identification. ```ps``` command reports a snapshot of the current processes.

Under the Standard I/O Library, the equivalent of the low-level file descriptor is called a strem and is implemented
as a pointer to a structure, a FILE *.

Three file streams are automatically opened when a program is started. They are stdin, stdout and stderr. These are
declared in stdio.h and represent the standard input, output and error output.

### Thread

Threads of execution, often shortened to threads, are the objects of activity within the process. Each thread includes
a unique:

- Program counter
- Process stack
- Set of processor registers

The kernel schedules individual threads, not processes.

### Process vs Thread

In traditional Unix systems, each process consists of one thread. In modern systems, multithreaded programs - those that
consist of more than one thread - are common. 

Linux has a unique implementation of threads: it does not differentiate between threads and
processes. To Linux, a thread is just a special kind of process.

### procfs - file system

Linux provide a special file system, procfs, that is usually made available as the directory /proc. It contains many
special files that allow higher-level access to driver and kernel information. Applications can read and write these
files to get information and set parameters as long as they are running with the correct access permissions.

### Inter-Process Communication 

# TO DO: UPDATE PROCESS SECTION USING CH. 3 - how to create one - ch. 3 - Linux Kernels Development
Another name for a process is a task

## Signals 

Most fundamental inter-process communication:

- Sent directly to processes, no user interface required
- Programs associate actions with each signal
- Signals are specified by name or number when sent (check ```man 7 signal``` for a list of signals names and numbers)
 
### Synchronization and messaging mechanisms
 
Semaphores, queues, pipes, etc.

## Application Binary Interface

The calling convention used for passing parameters between function calls. 

For ARM exist the Extended ABI (EABI) and the Extended ABI Hard-Float (EABIHF) which
useas floating point registers. They are incompatible between each other.

## C Library

The programming interface to the Unix operating system is defined in the C language,
which is now defined by the POSIX standards. The **C library** is the implementation
of that interface; it is the gateway to the kernel for Linux programs. Even if you're
writing programs in another language, maybe Java or Python, the respective runtime support
libraries will have to call the C library eventually.

![c_library(./img/c_lib.jpg)

Whenever the C library needs the services of the kernel, it will use the kernel system call
interface to transition between user space and kernel space.

Main options of C libraries:

  - glibc: standard GNU C library. The most complete implementation of the POSIX API
  - musl libc: good choice for systems with a limited amount of RAM and storage
  - uClibc-ng: microcontroller C library
  - eglibc: obsolete, not longer maintained - DON'T USE IT

## Useful commands

* find
* grep

You use find to search your system for files, but you use grep to search files for strings.

## System Calls and Device Drivers

You can access and control files and devices using a small number of functions. These functions, known
as *system calls*, are provided by UNIX (and Linux) directly, and are the interface to the operating
system itself.

At the hard of the operating system, the kernel, are a number of *device drivers*. These are a collection
of low-level interfaces for controlling system hardware. To provide a similar interface, device drivers
encapsulate all of the hardware-dependent features.

Drivers examples:

  - Tape Drive - knows hot to start the tape, wind it forward and backward, read and write to it, and so on.
  It will also know that tapes have to be written to in blocks of a certain size. 

  - Low-level Hard Disk - will only write whole numbers of disk sectors at a time, but will be able to access
  any desired disk block directly, because the disk is a random access device.

Device files in /dev are used in the same way; they can be opened, read, written, and closed. For example, the
same *open* call used to access a regular file is used to access a user terminal, a printer, or a tape drive.

## Frequently asked questions:

- Difference between static and dynamic directories? Is /dev directory static or dynamic? - https://unix.stackexchange.com/questions/97642/what-does-it-mean-when-something-says-that-unix-device-files-are-static
- Minimum directories needed in rootfs in order for the system be able to boot?
- Systemv vs systemd
- Remove a device from /dev
- What's stored in /etc? Configuration files
- How to configure USB port to only accept devices from a certain device - id vendor
