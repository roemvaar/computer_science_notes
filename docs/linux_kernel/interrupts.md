---
layout: default
title: Interrupts
parent: Linux Kernel
nav_order: 1
---

# Interrupts

An interrupt is an event that alters the normal execution flow of a program and can be generated by hardware devices or the CPU itself. When an interrupt occurs, the current flow of execution is suspended, and interrupt handlers run. After the interrupt handler runs, the previous execution flow is resumed.

Grouped by source:

* **Synchronous:** generated by executing an instruction and also called exceptions. Divide by zero or a system call are examples of synchronous interrupts.

* **Asynchronous:** generated by an external event. Usually called “interrupts”. These interrupts are external events generated by I/O devices. For example, a network card generates an interrupt to signal that a packet has arrived.

[Interrupt](https://docs.kernel.org/core-api/entry.html#interrupts-and-regular-exceptions) entry and exit handling is slightly more complex than syscalls. If an interrupt is raised while the CPU executes in user space, the entry and exit handling is the same as for syscalls.

It is important to initialize hardware and register an interrupt handler in the proper order to prevent the interrupt handler from running before the device is fully initialized.

## Interrupt Mechanisms

An interrupt mechanism is a way for devices or subsystems to signal the processor when they require immediate attention. It allows the CPU to pause its current task, handle the interrupt, and resume. This model enables modern systems to handle asynchronous events without the CPU continuously polling the devices.

We have three interrupt mechanisms:

* **SoftIRQs:** run immediately in interrupt context.

* **Tasklets:** serve as lower-priority bottom halves for deferred work processing. Tasklets are scheduled and executed in a serialized manner to prevent concurrency issues. Tasklets are being **deprecated**.

* **Workqueues:** run in process context. Workqueues provide a way to handle non-time-critical tasks asynchronously outside interrupt context.

The primary criteria for differentiating the mechanisms are the context in which each runs.

## Interrupt Mechanism

1. Interrupt occurrence: hardware device generates an interrupt signal. CPU interrupts its current task and enters the interrupt handler.

2. Interrupt handler: the interrupt handler executes to handle the interrupt. It performs time-critical and minimal processing to acknowledge and service the interrupt. For certain types of interrupts, the handler may schedule bottom half processing.

3. Bottom half scheduling: if needed, the interrupt handler schedules, bottom half processing to handler less time-critical tasks or deferred work. Bottom halves are scheduled based on the nature of the processing required and the priority of the task.

## What is an IRQ?

An IRQ is an interrupt request from a device. Currently they can come in over a pin, or over a packet. Several devices may be connected to the same pin thus sharing an IRQ.

An IRQ number is a kernel identifier used to talk about a hardware interrupt service. Typically this is an index into the global `irq_desc` array, but except for what Linux/interrupt.h implements the details are architecture specific.

An IRQ number is an enumeration of the possible interrupt sources on a machine. Typically what is enumerated is the number of input pins on all of the interrupt controllers in the system.

Architectures can assign additional meaning to the IRQ numbers, and are encouraged to in the case where there is any manual configuration of the hardware involved. The ISA IRQs are a classic example of assigning this kind of additional meaning.

The role of the interrupt handler depends entirely on the device and its reasons for issuing the interrupt. At a minimum, most interrupts handlers need to provide acknowledgement to the device that they received the interrupt. Devices that are more complex need to additionally send and receive data and perform extended work in the interrupt handler. The extended work is pushed as much as possible into the bottom half handler.

## Reentrancy and Interrupt Handlers

Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is executing, the corresponding interrupt line is masked out on all processors, **preventing another interrupt on the same line from being received**. Normally all other interrupts are enabled, so other interrupts are serviced, but the current line is always disabled. Consequently, the same interrupt handler is never invoked concurrently to service a nested interrupt. This greatly simplifies writing your interrupt handler.

You can have shared handlers. When the kernel receives an interrupt, it invokes sequentially each registered handler on the line.

## How long is the interrupt latency in Linux?

## Describe the process of exception handling, i.e., interrupt handling mechanism, in the Linux kernel

The Linux kernel includes a variety of exception handlers for different types of interrupts, including hardware interrupts, software interrupts, and system calls.

1. Saves the state of the interrupted process

2. Determines the cause of the interrupt

3. Executes the appropriate interrupt handler for the interrupt type

4. Restores the state of the interrupted process and resumes its execution
